<!DOCTYPE html>
<html>

<head>
  <style>
    :root {
      --accent-color: #1967D2;
      --accent-color-alpha30: #1967D24d;
      --accent-color-alpha60: #1967D299;
      --accent-color-alpha40: hsla(215, 79%, 46%, 0.4);
    }

    body {
      font-family: "Inter", sans-serif;
      padding: 2px 4px;
      margin: 0;
      height: 100vh;
      box-sizing: border-box;
      color: var(--figma-color-text);
      background-color: var(--figma-color-bg);
      overflow: hidden; /* Prevent body scroll */
    }

    h4 {
      margin-top: 0;
      color: var(--figma-color-text);
    }

    .search-container {
      position: sticky;
      top: 0;
      z-index: 1;
      background: var(--figma-color-bg);
      padding: 8px 4px;
      margin-bottom: 8px;
      display: flex;
      gap: 8px;
    }

    #components-search-input,
    #icons-search-input {
      flex-grow: 1;
      padding: 10px;
      border: 1.5px solid var(--figma-color-border);
      border-radius: 10px;
      font-size: 14px;
      width: 100%;
      box-sizing: border-box;
      background: var(--figma-color-bg);
      color: var(--figma-color-text);
      outline: none;
      transition: all ease .2s;
    }

    #components-search-input:hover, #components-search-input:focus,
    #icons-search-input:hover, #icons-search-input:focus {
      border-color: var(--figma-color-border-hover);
      outline: none;
    }

    #components-search-input::placeholder,
    #icons-search-input::placeholder {
      color: var(--figma-color-text-tertiary);
    }

    .refresh-button {
      background: var(--figma-color-bg-secondary);
      border: 1px solid var(--figma-color-border);
      border-radius: 10px;
      padding: 6px 12px;
      cursor: pointer;
      color: var(--figma-color-text);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all ease .2s;
    }

    .refresh-button:hover {
      background: var(--figma-color-bg-brand);
      color: white;
    }

    #components-list,
    #icons-list {
      list-style: none;
      padding: 0;
      margin-top: 0;
    }

    /* Style the scrollbar for webkit browsers (Chrome, Safari, etc.) */
    #components-list::-webkit-scrollbar,
    #icons-list::-webkit-scrollbar {
      width: 4px;
    }

    #components-list::-webkit-scrollbar-track,
    #icons-list::-webkit-scrollbar-track {
      background: var(--figma-color-bg);
    }

    #components-list::-webkit-scrollbar-thumb,
    #icons-list::-webkit-scrollbar-thumb {
      background: var(--figma-color-border);
      border-radius: 4px;
    }

    #components-list::-webkit-scrollbar-thumb:hover,
    #icons-list::-webkit-scrollbar-thumb:hover {
      background: var(--figma-color-text-tertiary);
    }

    /* Hide scrollbar for Firefox */
    #components-list,
    #icons-list {
      scrollbar-width: thin;
      scrollbar-color: var(--figma-color-border) transparent;
    }

    .component-item {
      margin: 5px;
    }

    .component-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 2px 0;
        border-radius: 4px;
        width: 100%;
        transition: background-color 0.2s;
        cursor: grab;
    }

    .component-content.dragging {
        opacity: 0.5;
        cursor: grabbing;
    }

    .component-content:hover {
        border-radius: 6px;
        background-color: var(--figma-color-bg-hover);
    }

    /* Add these new styles */
    .component-left {
        display: flex;
        align-items: center;
        gap: 14px;
    }

  .component-thumbnail {
      width: 30px;
      height: 30px;
      object-fit: contain;
      padding: 8px;
      border-radius: 6px;
      background: hsla(0, 0%, 70%, 0.25);
  }

	.component-thumbnail-icon {
		width: 24px;
		height: 24px;
		object-fit: contain;
		padding: 6px;
		border-radius: 8px;
		background: white;
	}

    .component-name {
      flex-grow: 1;
      font-size: .8rem;
      font-weight: 600;
    }

    .component-actions {
      display: flex;
      gap: 0px;
      margin-right: 6px;
    }

    .action-button {
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      transition: background-color 0.2s;
      color: var(--figma-color-text-secondary);
    }
    #close-dialog {
      margin-top: 10px;
      scale: 2;
    }

    .action-button:hover {
      background-color: var(--figma-color-bg-hover);
      color: var(--figma-color-text);
    }

    /* Style for the "No components found" message */
    .component-item li {
      color: var(--figma-color-text-tertiary);
      font-style: italic;
    }

    #status-message, #icons-status-message {
        margin-top: 18px;
        margin-bottom: 8px;
        font-size: 0.8rem;
        font-weight: 500;
        color: var(--figma-color-text-secondary);
        padding: 0px 0px 0px 8px;
        cursor: pointer;
        transition: all ease 0.2s;
    }
    .compact-mode #status-message,
    .compact-mode #icons-status-message {
      margin-top: 12px;
      font-size: 0.6rem;
      font-weight: 500;
      color: var(--figma-color-text-secondary);
      padding: 0px 0px 0px 8px;
      cursor: pointer;
      transition: all ease 0.2s;
    }

    #status-message:hover,
    #icons-status-message:hover {
      color: var(--figma-color-text-brand);
    }

    /* Radio button styles */
    .source-selector {
      margin-bottom: 16px;
    }

    .source-option {
      margin-right: 12px;
    }

    /* Tab styles */
    .tabs {
      position: sticky;
      top: 0;
      z-index: 2;
      display: flex;
      border-bottom: 1px solid var(--figma-color-border);
      background-color: var(--figma-color-bg);
    }

    .tab {
      padding: 8px 12px;
      cursor: pointer;
      color: var(--figma-color-text-secondary);
      border-bottom: 2px solid transparent;
      margin-right: 0px;
      font-weight: 500;
      transition: color ease .2s;
    }
    .tab:hover {
      cursor: pointer;
      color: var(--figma-color-text-primary);
      border-bottom: 2px solid transparent;
    }

    .tab.active {
      color: var(--figma-color-text);
      border-bottom: 2px solid var(--figma-color-text-brand);
      font-weight: 600;
    }

    .tab-container {
      height: calc(100vh - 20px); /* Adjust for body padding */
      display: flex;
      flex-direction: column;
    }

    .tab-content {
      display: none;
      height: 100%;
      overflow-y: auto;
      position: relative;
    }

    .tab-content.active {
      display: block;
    }

    ::-webkit-scrollbar {
      width: 6px; /* Thinner scrollbar */
    }
    /* Style the scrollbar for webkit browsers */
    #component-list::-webkit-scrollbar,
    #icons-list::-webkit-scrollbar {
      width: 6px; /* Thinner scrollbar */
    }

    #component-list::-webkit-scrollbar-track,
    #icons-list::-webkit-scrollbar-track {
      background: transparent; /* Transparent track */
    }

    #component-list::-webkit-scrollbar-thumb,
    #icons-list::-webkit-scrollbar-thumb {
      background: var(--figma-color-text-tertiary);
      border-radius: 6px;
      opacity: 0.5;
    }

  ::-webkit-scrollbar-thumb {
      background: var(--figma-color-text-tertiary);
      border-radius: 6px;
      opacity: 0.5;
    }

    #component-list::-webkit-scrollbar-thumb:hover,
    #icons-list::-webkit-scrollbar-thumb:hover {
      background: var(--figma-color-text-secondary);
    }

    /* For Firefox */
    #component-list,
    #icons-list {
      scrollbar-width: thin;
      scrollbar-color: var(--figma-color-text-tertiary) transparent;
    }

    .icon-swatch {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.1);
      font-family: "Inter", sans-serif;
      font-weight: bold;
      font-size: 12px;
    }

    .icon-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 4px;
      padding: 8px;
      margin-bottom: 18px;
    }

  .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      cursor: pointer;
      padding: 8px 0px 8px 0px;
      margin-bottom: 8px;
      border-radius: 6px;
      transition: background-color 0.2s;
  }

    .icon-item:hover {
      background-color: var(--figma-color-bg-hover);
    }

    .icon-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      width: 100%;
    }

    .icon-name {
      font-size: 0.65rem;
      font-weight: 400;
      color: var(--figma-color-text);
      word-break: break-word;
      max-width: 100%;
    }

    .icon-actions {
      opacity: 0;
      transition: opacity 0.2s;
    }

    .icon-item:hover .icon-actions {
      opacity: 1;
    }


    /* Add styles for the dialog */
    .dialog {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        color: var(--figma-color-text);
        padding: 0 14px 0 14px;
        box-sizing: border-box;
        z-index: 10;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s ease, visibility 0.2s ease;
    }

    .dialog.visible {
        opacity: 1;
        visibility: visible;
    }

    .dialog-content {
        background: var(--figma-color-bg);
        padding: 16px 0px;
        width: 100%;
        height: 100%;
        max-height: 100vh;
        transform: translateY(10px);
        transition: transform 0.2s ease;
    }

    .dialog.visible .dialog-content {
        transform: translateY(0);
    }

    .dialog-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 16px;
    }

    .properties-container {
      margin-bottom: 24px;
    }

    .property-group {
      margin-bottom: 18px;
    }

    .property-label {
      font-size: 11px;
      color: var(--figma-color-text-secondary);
      margin-bottom: 8px;
    }

    #create-variant {
        background: var(--figma-color-bg-secondary);
        border: 1px solid var(--figma-color-border);
        border-radius: 10px;
        padding: 8px 16px;
        cursor: pointer;
        color: var(--figma-color-text);
        display: flex;
        font-weight: 600;
        font-size: 16px;
        align-items: center;
        justify-content: center;
        margin-top: 18px;
        transition: all ease .2s;
    }

    #create-variant:hover {
      border: 1px solid var(--accent-color);
      background: var(--accent-color-alpha60);
      color: white;
    }

    .property-select {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--figma-color-border);
      border-radius: 6px;
      background: var(--figma-color-bg);
      color: var(--figma-color-text);
      font-size: 12px;
      cursor: pointer;
      transition: all ease .2s;
    }
    .property-select option {
      font-size: 12px;
    }
    .property-select:hover, .property-select:focus {
      border-color: var(--figma-color-border-hover);
      outline: none;
    }

    /* Add these styles for the property inputs */
    .property-input {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--figma-color-border);
      border-radius: 6px;
      background: var(--figma-color-bg);
      color: var(--figma-color-text);
      font-size: 12px;
      box-sizing: border-box;
      transition: all ease .2s;
    }

    .property-input:hover, .property-input:focus {
      border-color: var(--figma-color-border-hover);
      outline: none;
    }

    .property-checkbox {
      margin-right: 4px;
    }

    .property-label {
      font-size: 11px;
      color: var(--figma-color-text-secondary);
      margin-bottom: 8px;
      font-weight: 500;
    }

    /* Toggle switch styles */
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 32px;
      height: 16px;
      margin-right: 8px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--figma-color-bg-disabled);
      transition: .3s;
      border-radius: 34px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 12px;
      width: 12px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: .3s;
      border-radius: 50%;
    }

    input:checked + .toggle-slider {
      background-color: var(--accent-color);
    }

    input:checked + .toggle-slider:before {
      transform: translateX(16px);
    }

    /* Multi-line text area styles */
    .property-textarea {
      width: 100%;
      min-height: 60px;
      padding: 8px;
      border: 1px solid var(--figma-color-border);
      border-radius: 6px;
      background: var(--figma-color-bg);
      color: var(--figma-color-text);
      font-size: 12px;
      box-sizing: border-box;
      font-family: "Inter", sans-serif;
      resize: vertical;
      line-height: 1.4;
      transition: all ease .2s;
    }

    .property-textarea:hover, .property-textarea:focus {
      border-color: var(--figma-color-border-hover);
      outline: none;
    }

    /* Property container with label and input in one row */
    .boolean-property {
      display: flex;
      align-items: center;
    }

    .boolean-property .property-label {
      margin-bottom: 0;
      opacity: 0;
      flex: 1;
    }

    /* Documentation button styles */
    .docs-button {
      background: none;
      border: none;
      cursor: pointer;
      padding: 8px 10px;
      margin-left: auto; /* Push to the right side */
      color: var(--figma-color-text-brand);
      font-size: 16px;
      transition: all 0.2s ease;
      border-radius: 4px;
      font-weight: bold;
    }

    .docs-button:hover {
      background-color: var(--figma-color-bg-hover);
      color: var(--figma-color-text);
    }

    /* Add these styles for the size toggle button */
    .size-toggle-expanded {
      transform: rotate(90deg);
    }

    /* Compact mode specific styles */
    .compact-mode .component-item {
      margin: 2px;
    }

    .compact-mode .component-left {
      gap: 10px;
    }

    .compact-mode .component-thumbnail {
      width: 25px;
      height: 25px;
      padding: 6px;
    }

    .compact-mode .component-name {
      font-size: 0.7rem;
      font-weight: 500;
    }

    .compact-mode .icon-grid {
      grid-template-columns: repeat(4, 1fr);
    }

    .compact-mode .icon-name {
      font-size: 0.55rem;
    }

    .compact-mode .component-thumbnail-icon {
      width: 24px;
      height: 24px;
      padding: 6px;
    }

    /* Adjust the search container in compact mode */
    .compact-mode .search-container {
        padding: 6px 2px;
        gap: 8px;
    }

    .compact-mode #components-search-input,
    .compact-mode #icons-search-input {
      padding: 8px;
    }

    .compact-mode .refresh-button {
      padding: 4px 10px;
    }
    .compact-mode .icon-item {
      margin-bottom: 0px;
    }
    .compact-mode .tab {
      font-size: .8rem;
    }
    .compact-mode #docs-button {
      display: none;
    }

    /* Add styles for categories */
    .category-header {
      font-size: 0.9rem;
      font-weight: 600;
      border-bottom: 1px solid var(--figma-color-border);
      color: var(--figma-color-text);
      transition: all 0.2s ease;
      padding: 8px 6px 8px 6px;
      margin-bottom: 4px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
    }

    .category-header:hover {
      color: var(--figma-color-text);
    }
    .category-header.collapsed {
      font-weight: 500;
      font-size: 0.8rem;
      color: var(--figma-color-text-secondary);
    }
    .category-header.collapsed:hover {
      color: var(--figma-color-text);
    }

    /* Special styling for the last category */
    .category-header.last-category.collapsed {
      border-bottom: none;
    }

    .category-toggle {
      margin-right: 4px;
      transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      transform: rotate(-180deg);
    }

    .category-toggle svg {
      color: var(--figma-color-text-secondary);
      width: 100%;
      height: 100%;
    }

    .category-header:hover .category-toggle svg {
      color: var(--figma-color-text);
    }

    .category-header.collapsed .category-toggle {
      transform: rotate(0deg);
    }

    .category-section {
      margin-bottom: 6px;
      padding: 0 2px;
      overflow: hidden;
      transition: max-height 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .category-section.collapsed {
      max-height: 0;
      margin-bottom: 0px;
    }

    .compact-mode .category-header {
        padding: 8px 6px 8px 6px;
    }

    #toggle-all-icon {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #toggle-all-icon svg {
      color: currentColor;
      width: 100%;
      height: 100%;
      transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #toggle-all-icon.collapsed svg {
      transform: rotate(-180deg);
    }
  </style>
</head>

<body>
  <div class="tab-container">
    <div class="tabs">
      <div class="tab active" data-tab="components-tab">Components</div>
      <div class="tab" data-tab="icons-tab">Icons</div>
      <button id="docs-button" class="docs-button" title="Open Documentation">🌐</button>
      <button id="size-toggle" class="docs-button" title="Toggle UI Size">⟷</button>
    </div>

    <div id="components-tab" class="tab-content active">
      <p id="status-message">Loading components...</p>
      <div class="search-container">
        <input type="text" id="components-search-input" placeholder="Search components...">
        <button id="refresh-components" class="refresh-button" title="Refresh components">↻</button>
        <button id="toggle-all-categories" class="refresh-button" title="Expand/Collapse All"><span id="toggle-all-icon"></span></button>
      </div>
      <ul id="components-list"></ul>
    </div>

    <div id="icons-tab" class="tab-content">
      <p id="icons-status-message">Loading icons...</p>
      <div class="search-container">
        <input type="text" id="icons-search-input" placeholder="Search icons...">
        <button id="refresh-icons" class="refresh-button" title="Refresh icons">↻</button>
        <button id="clear-icons-cache" class="refresh-button" title="Clear Icons Cache">🗑️</button>
      </div>
      <ul id="icons-list"></ul>
    </div>
  </div>

  <!-- Add this new section below the existing content in the body -->
  <div id="component-properties"
       class="dialog"
       role="dialog"
       aria-labelledby="dialog-title"
       aria-modal="true">
    <div class="dialog-content">
      <div class="dialog-header">
        <h4>Component Properties</h4>
        <button id="close-dialog" class="action-button">×</button>
      </div>
      <div class="properties-container">
        <div id="variant-properties"></div>
        <div id="instance-properties"></div>
      </div>
      <button id="create-variant" class="refresh-button">Create Instance</button>
    </div>
  </div>

  <script>
    // Helper function to load SVG icons
    function createSvgIcon(svgPath, className = '') {
      const svgContainer = document.createElement('div');
      svgContainer.className = className;

      // Instead of fetching from files, use inline SVG content
      let svgContent = '';

      if (svgPath.includes('down')) {
        // Chevron down SVG
        svgContent = '<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512"><polyline points="112 184 256 328 400 184" style="fill:none;stroke:currentColor;stroke-linecap:round;stroke-linejoin:round;stroke-width:48px"/></svg>';
      } else if (svgPath.includes('up')) {
        // Chevron up SVG
        svgContent = '<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512"><polyline points="112 328 256 184 400 328" style="fill:none;stroke:currentColor;stroke-linecap:round;stroke-linejoin:round;stroke-width:48px"/></svg>';
      } else {
        // Fallback to text
        svgContainer.textContent = svgPath.includes('up') ? '▲' : '▼';
        return svgContainer;
      }

      svgContainer.innerHTML = svgContent;

      // Set the color to currentColor for better theming
      const svgElement = svgContainer.querySelector('svg');
      if (svgElement) {
        svgElement.style.width = '100%';
        svgElement.style.height = '100%';
      }

      return svgContainer;
    }

    // Handle tab switching
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');
    let componentsData = [];
    let iconsData = [];
    let currentComponentData = null;

    // Add loading state management
    function setLoadingState(tabId, isLoading) {
      const statusMessage = tabId === 'components-tab' ?
        document.getElementById('status-message') :
        document.getElementById('icons-status-message');

      if (isLoading) {
        statusMessage.textContent = "Loading...";
        statusMessage.style.color = "var(--figma-color-text-secondary)";
      } else {
        if (tabId === 'components-tab') {
          // Count total components across all categories
          const totalComponents = componentsData.reduce((total, category) =>
            category.isCategory ? total + category.items.length : total, 0);
          statusMessage.textContent = `Found ${totalComponents} components.`;
        } else {
          statusMessage.textContent = `Found ${iconsData.length} icons.`;
        }
        statusMessage.style.color = "var(--figma-color-text)";
      }
    }

    // Set up refresh buttons
    document.getElementById('refresh-components').addEventListener('click', () => {
      document.getElementById('status-message').textContent = "Refreshing components...";
      parent.postMessage({
        pluginMessage: {
          type: 'refresh',
          target: 'components'
        }
      }, '*');
    });

    document.getElementById('refresh-icons').addEventListener('click', () => {
      document.getElementById('icons-status-message').textContent = "Refreshing icons...";
      parent.postMessage({
        pluginMessage: {
          type: 'refresh',
          target: 'icons'
        }
      }, '*');
    });

    // Keep this event listener
    document.getElementById('clear-icons-cache').addEventListener('click', () => {
      parent.postMessage({
        pluginMessage: { type: 'clear-icons-cache' }
      }, '*');
    });

    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        // Remove active class from all tabs and contents
        tabs.forEach(t => t.classList.remove('active'));
        tabContents.forEach(c => c.classList.remove('active'));

        // Add active class to clicked tab and corresponding content
        tab.classList.add('active');
        const tabId = tab.getAttribute('data-tab');
        document.getElementById(tabId).classList.add('active');

        // Set loading state
        setLoadingState(tabId, true);

        // Notify the plugin about tab change
        parent.postMessage({
          pluginMessage: {
            type: 'tab-change',
            tab: tabId
          }
        }, '*');
      });
    });

    // Handle messages from the plugin
    window.onmessage = (event) => {
      const data = event.data.pluginMessage;

      // Handle components data (Tab 1)
      if (data && data.components) {
        componentsData = data.components;
        renderComponents();
      }

      // Handle collapsed state
      if (data && data.type === 'collapsed-state') {
        window.collapsedCategoriesState = data.collapsedCategories;
        // If we already have components rendered, update the UI
        if (componentsData && componentsData.length > 0) {
          renderComponents();
        }
      }

      // Handle icons data (Tab 2)
      if (data && data.icons) {
        iconsData = data.icons;
        renderIcons();
      }

      // Handle icon updates
      if (data && data.iconsUpdate) {
        // Update specific icons with thumbnails
        const updateStartIndex = data.iconsUpdateStartIndex || 0;

        for (let i = 0; i < data.iconsUpdate.length; i++) {
          const index = updateStartIndex + i;
          if (index < iconsData.length) {
            // Update the icon data
            iconsData[index] = data.iconsUpdate[i];
          }
        }

        // Re-render the current view
        renderIcons();
      }

      // Handle status messages
      if (data && data.status) {
        document.getElementById('status-message').textContent = data.status;
      }

      if (data && data.iconsStatus) {
        document.getElementById('icons-status-message').textContent = data.iconsStatus;
      }

      // Handle errors
      if (data && data.error) {
        document.getElementById('status-message').textContent = data.error;
        document.getElementById('status-message').style.color = '#FF0000';
      }

      if (data && data.iconsError) {
        document.getElementById('icons-status-message').textContent = data.iconsError;
        document.getElementById('icons-status-message').style.color = '#FF0000';
      }

      // Handle showing component properties
      if (data && data.type === "show-component-properties") {
        const properties = data.properties;
        currentComponentData = properties;
        const variantPropertiesContainer = document.getElementById('variant-properties');
        variantPropertiesContainer.innerHTML = '';

        // Update dialog title to reflect we're editing an existing instance
        document.querySelector('.dialog-header h4').textContent = data.instanceId ?
          "Edit Component Properties" : "Component Properties";

        // Update the button text
        const actionButton = document.getElementById('create-variant');
        actionButton.textContent = data.instanceId ? "Done" : "Create Instance";

        // First, handle variant properties as they should appear at the top
        const variantProps = [];
        const textProps = [];
        const otherProps = [];

        // Sort properties into categories
        Object.entries(properties.componentProperties).forEach(([key, definition]) => {
          // Clean the property name - remove ID suffixes (anything after #)
          const cleanPropertyName = key.split('#')[0];

          // Store both original key and clean name
          const propData = {
            originalKey: key,
            cleanName: cleanPropertyName,
            definition: definition
          };

          // Sort by type
          if (definition.type === 'VARIANT') {
            variantProps.push(propData);
          } else if (definition.type === 'TEXT') {
            textProps.push(propData);
          } else {
            otherProps.push(propData);
          }
        });

        // Combine all properties in the desired order
        const sortedProps = [...variantProps, ...textProps, ...otherProps];

        // Create UI for sorted properties
        sortedProps.forEach(({originalKey, cleanName, definition}) => {
          console.log("Creating input for property:", cleanName, definition);
          const propertyGroup = document.createElement('div');
          propertyGroup.className = 'property-group';

          const label = document.createElement('div');
          label.className = 'property-label';
          label.textContent = cleanName; // Use the clean name without ID suffix
          propertyGroup.appendChild(label);

          // Create different input types based on property type
          if (definition.type === 'VARIANT') {
            const select = document.createElement('select');
            select.className = 'property-select';
            select.dataset.property = originalKey;
            select.dataset.type = 'VARIANT';

            // Add options for variant properties
            if (definition.variantOptions) {
              definition.variantOptions.forEach(option => {
                const optionEl = document.createElement('option');
                optionEl.value = option;
                optionEl.textContent = option;
                if (option === (definition.currentValue || definition.defaultValue)) {
                  optionEl.selected = true;
                }
                select.appendChild(optionEl);
              });
            }

            // Add live update event
            select.addEventListener('change', (e) => {
              if (currentComponentData && currentComponentData.instanceId) {
                const propUpdate = {};
                propUpdate[originalKey] = e.target.value;

                parent.postMessage({
                  pluginMessage: {
                    type: 'live-update-property',
                    instanceId: currentComponentData.instanceId,
                    properties: propUpdate
                  }
                }, '*');
              }
            });

            propertyGroup.appendChild(select);
          }
          else if (definition.type === 'TEXT') {
            // Check if this is a multi-line text property (usually larger text blocks)
            const isMultiline = originalKey.toLowerCase().includes('description') ||
                                 originalKey.toLowerCase().includes('content') ||
                                 originalKey.toLowerCase().includes('subtext') ||
                                 originalKey.toLowerCase().includes('sub text') ||
                                 definition.defaultValue?.includes('\n') ||
                                 definition.defaultValue?.length > 80;

            if (isMultiline) {
              const textarea = document.createElement('textarea');
              textarea.className = 'property-textarea';
              textarea.dataset.property = originalKey;
              textarea.dataset.type = 'TEXT';
              textarea.value = definition.defaultValue || '';
              textarea.placeholder = 'Enter text...';
              textarea.rows = 3;

              // Auto-resize logic
              textarea.addEventListener('input', function() {
                // Reset height to auto to correctly calculate new height
                this.style.height = 'auto';
                // Set new height based on scrollHeight with small buffer
                this.style.height = (this.scrollHeight + 4) + 'px';
              });

              // Trigger resize on initial load
              setTimeout(() => {
                textarea.style.height = (textarea.scrollHeight + 4) + 'px';
              }, 10);

              // Add live update event
              textarea.addEventListener('input', (e) => {
                if (currentComponentData && currentComponentData.instanceId) {
                  const propUpdate = {};
                  propUpdate[originalKey] = e.target.value;

                  parent.postMessage({
                    pluginMessage: {
                      type: 'live-update-property',
                      instanceId: currentComponentData.instanceId,
                      properties: propUpdate
                    }
                  }, '*');
                }
              });

              propertyGroup.appendChild(textarea);
            } else {
              // Regular single-line text input
              const input = document.createElement('input');
              input.type = 'text';
              input.className = 'property-input';
              input.dataset.property = originalKey;
              input.dataset.type = 'TEXT';
              input.value = definition.defaultValue || '';
              input.placeholder = 'Enter text...';

              // Add live update event
              input.addEventListener('input', (e) => {
                if (currentComponentData && currentComponentData.instanceId) {
                  const propUpdate = {};
                  propUpdate[originalKey] = e.target.value;

                  parent.postMessage({
                    pluginMessage: {
                      type: 'live-update-property',
                      instanceId: currentComponentData.instanceId,
                      properties: propUpdate
                    }
                  }, '*');
                }
              });

              propertyGroup.appendChild(input);
            }
          }
          else if (definition.type === 'BOOLEAN') {
            // Create a container for the switch and label in one row, replacing the group label
            const booleanContainer = document.createElement('div');
            booleanContainer.className = 'boolean-property';

            // The label comes first in the row, using the property label directly
            const label = document.createElement('div');
            label.className = 'property-label';
            label.textContent = cleanName;
            booleanContainer.appendChild(label);

            // Create the toggle switch
            const toggleSwitch = document.createElement('label');
            toggleSwitch.className = 'toggle-switch';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.dataset.property = originalKey;
            checkbox.dataset.type = 'BOOLEAN';
            checkbox.checked = definition.defaultValue === 'true';

            const slider = document.createElement('span');
            slider.className = 'toggle-slider';

            toggleSwitch.appendChild(checkbox);
            toggleSwitch.appendChild(slider);
            booleanContainer.appendChild(toggleSwitch);

            // Add the boolean container directly to property group, without a separate label
            propertyGroup.appendChild(booleanContainer);

            // Add live update event
            checkbox.addEventListener('change', (e) => {
              if (currentComponentData && currentComponentData.instanceId) {
                const propUpdate = {};
                propUpdate[originalKey] = e.target.checked;

                parent.postMessage({
                  pluginMessage: {
                    type: 'live-update-property',
                    instanceId: currentComponentData.instanceId,
                    properties: propUpdate
                  }
                }, '*');
              }
            });
          }
          else if (definition.type === 'NUMBER') {
            const input = document.createElement('input');
            input.type = 'number';
            input.className = 'property-input';
            input.dataset.property = originalKey; // Keep original key for data
            input.dataset.type = 'NUMBER';
            input.value = definition.defaultValue || 0;

            // Add live update event
            input.addEventListener('input', (e) => {
              if (currentComponentData && currentComponentData.instanceId) {
                const propUpdate = {};
                propUpdate[originalKey] = parseFloat(e.target.value);

                parent.postMessage({
                  pluginMessage: {
                    type: 'live-update-property',
                    instanceId: currentComponentData.instanceId,
                    properties: propUpdate
                  }
                }, '*');
              }
            });

            propertyGroup.appendChild(input);
          }
          else if (definition.type === 'INSTANCE_SWAP') {
            // For advanced users we could provide component selection
            const label = document.createElement('div');
            label.textContent = '(Instance swap not supported in dialog)';
            label.style.fontSize = '10px';
            label.style.fontStyle = 'italic';
            propertyGroup.appendChild(label);
          }

          variantPropertiesContainer.appendChild(propertyGroup);
        });

        // Show the dialog with transition
        document.querySelector('.tab-container').style.display = 'none';
        const dialog = document.getElementById('component-properties');
        dialog.style.display = 'flex';
        void dialog.offsetWidth;
        dialog.classList.add('visible');
      }

      // Handle create variant button click
      document.getElementById('create-variant').onclick = () => {
        if (!currentComponentData) return;

        if (!currentComponentData.instanceId) {
          // Only collect and send properties if we're creating a new instance
          const properties = {};
          // Get all variants (dropdowns)
          const selects = document.querySelectorAll('.property-select');
          selects.forEach(select => {
            properties[select.dataset.property] = select.value;
          });

          // Get text inputs and textareas
          const textInputs = document.querySelectorAll('.property-input[data-type="TEXT"], .property-textarea');
          textInputs.forEach(input => {
            properties[input.dataset.property] = input.value;
          });

          // Get number inputs
          const numberInputs = document.querySelectorAll('.property-input[data-type="NUMBER"]');
          numberInputs.forEach(input => {
            properties[input.dataset.property] = parseFloat(input.value);
          });

          // Get checkboxes (now inside toggle switches)
          const checkboxes = document.querySelectorAll('input[type="checkbox"]');
          checkboxes.forEach(checkbox => {
            properties[checkbox.dataset.property] = checkbox.checked;
          });

          parent.postMessage({
            pluginMessage: {
              type: 'create-instance-with-properties',
              componentId: currentComponentData.id,
              properties: properties
            }
          }, '*');
        }

        // Close the dialog - this happens for both create and edit
        document.getElementById('close-dialog').click();
      };

      // Handle close dialog button click
      document.getElementById('close-dialog').onclick = () => {
        const dialog = document.getElementById('component-properties');
        dialog.classList.remove('visible');

        // Wait for transition to complete before hiding completely
        setTimeout(() => {
            dialog.style.display = 'none';
            document.querySelector('.tab-container').style.display = 'flex';
        }, 300); // Match the transition duration
      };
    };

    // Update the renderComponents function
    function renderComponents(searchTerm = '') {
      const componentsList = document.getElementById('components-list');
      componentsList.innerHTML = '';
      const componentsSearchInput = document.getElementById('components-search-input');
      searchTerm = searchTerm || componentsSearchInput.value;

      // Filter components based on search term
      const filteredComponents = componentsData.map(category => {
        if (!category.isCategory) return category;

        const filteredItems = category.items.filter(component =>
          component.name.toLowerCase().includes(searchTerm.toLowerCase())
        );

        return {
          ...category,
          items: filteredItems
        };
      });

      // Check if any category has items
      const hasAnyItems = filteredComponents.some(category =>
        category.isCategory && category.items.length > 0
      );

      if (!hasAnyItems) {
        componentsList.innerHTML = '<li style="color: #666; font-style: italic;">No components found</li>';
        return;
      }

      // Get collapsed state from global variable instead of localStorage
      const collapsedCategories = window.collapsedCategoriesState || {};

      filteredComponents.forEach((category, index) => {
        if (!category.isCategory) return;

        // Skip empty categories
        if (category.items.length === 0) return;

        // Create category header
        const categoryHeader = document.createElement('div');
        categoryHeader.className = 'category-header';

        // Add last-category class if this is "Other Components"
        if (category.category === "Other Components") {
          categoryHeader.classList.add('last-category');
        }

        if (collapsedCategories[category.category]) {
          categoryHeader.classList.add('collapsed');
        }

        // Add category title and toggle icon
        const categoryTitle = document.createElement('span');
        categoryTitle.textContent = category.category;

        // Create toggle icon using SVG
        const toggleIcon = createSvgIcon('chevron-down.svg', 'category-toggle');

        categoryHeader.appendChild(categoryTitle);
        categoryHeader.appendChild(toggleIcon);
        componentsList.appendChild(categoryHeader);

        // Create category section
        const categorySection = document.createElement('div');
        categorySection.className = 'category-section';
        if (collapsedCategories[category.category]) {
          categorySection.classList.add('collapsed');
        } else {
          categorySection.style.maxHeight = '1000px'; // Set a large enough max-height for expanded state
        }

        // Add click event for accordion toggle
        categoryHeader.addEventListener('click', () => {
          const isCollapsed = categoryHeader.classList.toggle('collapsed');
          categorySection.classList.toggle('collapsed');

          if (!isCollapsed) {
            // Expanded - set a height for animation immediately
            categorySection.style.maxHeight = categorySection.scrollHeight + 'px';
            // After animation completes, switch to auto height
            setTimeout(() => {
              categorySection.style.maxHeight = '1000px';
            }, 200); // Match the transition duration
          } else {
            // Collapsing - set height to 0 immediately (no delay)
            categorySection.style.maxHeight = '0px';
          }

          // Save collapsed state via message
          if (!window.collapsedCategoriesState) window.collapsedCategoriesState = {};
          window.collapsedCategoriesState[category.category] = isCollapsed;

          // Send updated state to plugin
          parent.postMessage({
            pluginMessage: {
              type: 'save-collapsed-state',
              collapsedCategories: window.collapsedCategoriesState
            }
          }, '*');
        });

        // Add components to category
        category.items.forEach(component => {
          const item = document.createElement('li');
          item.className = 'component-item';

          // Create container for component name and actions
          const content = document.createElement('div');
          content.className = 'component-content';
          content.draggable = true;

          // Add drag event handlers
          content.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('application/json', JSON.stringify({
              id: component.id,
              name: component.name
            }));
            content.classList.add('dragging');
          });

          content.addEventListener('dragend', () => {
            content.classList.remove('dragging');
          });

          // Add click handler to the content div
          content.onclick = (e) => {
            if (!e.target.closest('.action-button')) {
              parent.postMessage({ pluginMessage: { type: 'create-instance', id: component.id } }, '*');
            }
          };

          // Create left container for thumbnail/swatch and name
          const leftContent = document.createElement('div');
          leftContent.className = 'component-left';

          if (component.thumbnail) {
            const thumbnail = document.createElement('img');
            thumbnail.className = 'component-thumbnail';
            thumbnail.src = `data:image/png;base64,${component.thumbnail}`;
            thumbnail.alt = component.name;
            leftContent.appendChild(thumbnail);
          } else {
            const colorSwatch = document.createElement('div');
            colorSwatch.className = 'component-thumbnail icon-swatch';
            colorSwatch.style.backgroundColor = component.colorHash || '#cccccc';
            if (component.firstChar) {
              colorSwatch.textContent = component.firstChar;
              colorSwatch.style.color = getContrastColor(component.colorHash);
            }
            leftContent.appendChild(colorSwatch);
          }

          const name = document.createElement('span');
          name.textContent = component.name;
          name.className = 'component-name';
          name.style.cursor = 'pointer';
          leftContent.appendChild(name);

          content.appendChild(leftContent);

          const actions = document.createElement('div');
          actions.className = 'component-actions';

          const gotoBtn = document.createElement('button');
          gotoBtn.innerHTML = '→';
          gotoBtn.title = 'Go to Component';
          gotoBtn.className = 'action-button';
          gotoBtn.onclick = (e) => {
            e.stopPropagation();
            parent.postMessage({ pluginMessage: { type: 'goto-component', id: component.id } }, '*');
          };

          actions.appendChild(gotoBtn);
          content.appendChild(actions);
          item.appendChild(content);
          categorySection.appendChild(item);
        });

        componentsList.appendChild(categorySection);
      });

      // Update the toggle all button based on collapsed state
      const allCategoryHeaders = document.querySelectorAll('.category-header');
      const allCollapsed = Array.from(allCategoryHeaders).every(header =>
        header.classList.contains('collapsed')
      );

      // Update the toggle all icon class instead of swapping SVGs
      const toggleAllIcon = document.getElementById('toggle-all-icon');
      if (allCollapsed) {
        toggleAllIcon.classList.add('collapsed');
      } else {
        toggleAllIcon.classList.remove('collapsed');
      }
    }

    // Icon rendering function
    function renderIcons(searchTerm = '') {
      const iconsList = document.getElementById('icons-list');
      iconsList.className = 'icon-grid';
      iconsList.innerHTML = '';
      const iconsSearchInput = document.getElementById('icons-search-input');
      searchTerm = searchTerm || iconsSearchInput.value;

      const filteredIcons = iconsData.filter(icon =>
        icon.name.toLowerCase().includes(searchTerm.toLowerCase())
      );

      if (filteredIcons.length === 0) {
        iconsList.innerHTML = '<li style="color: #666; font-style: italic;">No icons found</li>';
        return;
      }

      filteredIcons.forEach(icon => {
        const item = document.createElement('div');
        item.className = 'icon-item';

        const content = document.createElement('div');
        content.className = 'icon-content';

        if (icon.thumbnail) {
          // Use actual thumbnail
          const thumbnail = document.createElement('img');
          thumbnail.className = 'component-thumbnail-icon';
          thumbnail.src = `data:image/png;base64,${icon.thumbnail}`;
          thumbnail.alt = icon.name;

          // Add error handling to the thumbnail image
          thumbnail.onerror = function() {
            // Replace with a fallback when image fails to load
            const parent = this.parentNode;
            parent.removeChild(this);

            // Create fallback color swatch instead
            const colorSwatch = document.createElement('div');
            colorSwatch.className = 'component-thumbnail icon-swatch';
            colorSwatch.style.backgroundColor = icon.colorHash || '#cccccc';
            if (icon.firstChar) {
              colorSwatch.textContent = icon.firstChar;
              colorSwatch.style.color = getContrastColor(icon.colorHash);
            }
            parent.prepend(colorSwatch);
          };

          content.appendChild(thumbnail);
        } else {
          // Fallback to color swatch with first letter
          const colorSwatch = document.createElement('div');
          colorSwatch.className = 'component-thumbnail icon-swatch';
          colorSwatch.style.backgroundColor = icon.colorHash || '#cccccc';
          if (icon.firstChar) {
            colorSwatch.textContent = icon.firstChar;
            colorSwatch.style.color = getContrastColor(icon.colorHash);
          }
          content.appendChild(colorSwatch);
        }

        // Icon name
        const name = document.createElement('span');
        name.textContent = icon.name;
        name.className = 'icon-name';
        content.appendChild(name);

        // Add click handler to the whole item
        item.onclick = (e) => {
            parent.postMessage({ pluginMessage: { type: 'create-instance', id: icon.id } }, '*');
        };

        item.appendChild(content);
        iconsList.appendChild(item);
      });
    }

    // Function to determine text color based on background color
    function getContrastColor(hexColor) {
      // Remove the # if it's there
      hexColor = hexColor.replace('#', '');

      // Convert to RGB
      const r = parseInt(hexColor.substr(0, 2), 16);
      const g = parseInt(hexColor.substr(2, 2), 16);
      const b = parseInt(hexColor.substr(4, 2), 16);

      // Calculate brightness (YIQ formula)
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;

      // Return white for dark colors, black for light colors
      return brightness > 128 ? '#000000' : '#ffffff';
    }

    // Add debounce function
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Add search functionality for components with debounce
    document.getElementById('components-search-input').addEventListener('input', debounce((e) => {
      renderComponents(e.target.value);
    }, 300));

    // Add search functionality for icons with debounce
    document.getElementById('icons-search-input').addEventListener('input', debounce((e) => {
      renderIcons(e.target.value);
    }, 300));

    // Add event listener for documentation button
    document.getElementById('docs-button').addEventListener('click', () => {
      // Open documentation in a new tab
      window.open('http://moelle.bplaced.net/index.html', '_blank');
    });

    // Add export functionality to status messages
    document.getElementById('status-message').addEventListener('click', () => {
      if (componentsData.length === 0) return;

      // Format the data as a simple JSON structure
      const exportData = componentsData.map(component => ({
        id: component.id,
        name: component.name
      }));

      // Create a fallback copy method using execCommand
      const textToCopy = JSON.stringify(exportData, null, 2);
      const textarea = document.createElement('textarea');
      textarea.value = textToCopy;
      textarea.style.position = 'fixed';  // Avoid scrolling to bottom
      document.body.appendChild(textarea);
      textarea.select();

      try {
        const successful = document.execCommand('copy');
        if (successful) {
          const originalText = document.getElementById('status-message').textContent;
          document.getElementById('status-message').textContent = "✓ Components data copied to clipboard!";
          setTimeout(() => {
            document.getElementById('status-message').textContent = originalText;
          }, 2000);
        } else {
          console.error('Copy command was unsuccessful');
        }
      } catch (err) {
        console.error('Failed to copy: ', err);
      } finally {
        document.body.removeChild(textarea);
      }
    });

    document.getElementById('icons-status-message').addEventListener('click', () => {
      if (iconsData.length === 0) return;

      // Format the data as a simple JSON structure
      const exportData = iconsData.map(icon => ({
        id: icon.id,
        name: icon.name
      }));

      // Create a fallback copy method using execCommand
      const textToCopy = JSON.stringify(exportData, null, 2);
      const textarea = document.createElement('textarea');
      textarea.value = textToCopy;
      textarea.style.position = 'fixed';  // Avoid scrolling to bottom
      document.body.appendChild(textarea);
      textarea.select();

      try {
        const successful = document.execCommand('copy');
        if (successful) {
          const originalText = document.getElementById('icons-status-message').textContent;
          document.getElementById('icons-status-message').textContent = "✓ Icons data copied to clipboard!";
          setTimeout(() => {
            document.getElementById('icons-status-message').textContent = originalText;
          }, 2000);
        } else {
          console.error('Copy command was unsuccessful');
        }
      } catch (err) {
        console.error('Failed to copy: ', err);
      } finally {
        document.body.removeChild(textarea);
      }
    });

    // Update the size-toggle event listener
    document.getElementById('size-toggle').addEventListener('click', () => {
      const isExpanded = document.body.classList.toggle('expanded-ui');
      document.getElementById('size-toggle').classList.toggle('size-toggle-expanded');

      // Toggle the compact-mode class (remove when expanded, add when compact)
      document.body.classList.toggle('compact-mode', !isExpanded);

      // Send message to plugin to resize the UI
      parent.postMessage({
        pluginMessage: {
          type: 'resize',
          size: isExpanded ? 'expanded' : 'compact'
        }
      }, '*');
    });

    // Add code to set the initial state when the plugin loads
    window.addEventListener('load', () => {
      // Default to compact mode when plugin loads
      document.body.classList.add('compact-mode');
    });

    // Add toggle all categories functionality
    document.getElementById('toggle-all-categories').addEventListener('click', () => {
      const allCategoryHeaders = document.querySelectorAll('.category-header');
      const allCategorySections = document.querySelectorAll('.category-section');

      // Check if all categories are collapsed
      const allCollapsed = Array.from(allCategoryHeaders).every(header =>
        header.classList.contains('collapsed')
      );

      // Toggle based on current state
      const collapsedCategories = {};

      allCategoryHeaders.forEach((header, index) => {
        const section = allCategorySections[index];

        if (allCollapsed) {
          // Expand all
          header.classList.remove('collapsed');
          section.classList.remove('collapsed');
          section.style.maxHeight = '1000px';
          collapsedCategories[header.querySelector('span').textContent] = false;
        } else {
          // Collapse all
          header.classList.add('collapsed');
          section.classList.add('collapsed');
          section.style.maxHeight = '0px';
          collapsedCategories[header.querySelector('span').textContent] = true;
        }
      });

      // Update the toggle all icon class instead of swapping SVGs
      const toggleAllIcon = document.getElementById('toggle-all-icon');
      if (allCollapsed) {
        toggleAllIcon.classList.add('collapsed');
      } else {
        toggleAllIcon.classList.remove('collapsed');
      }

      // Save state to global variable
      window.collapsedCategoriesState = collapsedCategories;

      // Send updated state to plugin
      parent.postMessage({
        pluginMessage: {
          type: 'save-collapsed-state',
          collapsedCategories: window.collapsedCategoriesState
        }
      }, '*');
    });

    // Initialize the toggle all icon on page load to use just chevron-down
    window.addEventListener('DOMContentLoaded', () => {
      const toggleAllIcon = document.getElementById('toggle-all-icon');
      toggleAllIcon.appendChild(createSvgIcon('chevron-down.svg'));
    });
  </script>
</body>

</html>