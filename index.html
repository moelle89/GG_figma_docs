<!DOCTYPE html>
<html lang="en" data-theme="light">
<link rel="icon" type="image/png" href="assets/fav/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="assets/fav/favicon.svg" />
<link rel="shortcut icon" href="assets/fav/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="assets/fav/apple-touch-icon.png" />

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Component Library</title>
    <link rel="stylesheet" href="css/slider.css" />
    <link rel="stylesheet" href="css/comp_cards.css" />
    <link rel="stylesheet" href="css/app.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
</head>

<body>

    <div class="main-container">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-search">
                <div class="search-container">
                    <input type="text" class="search-input" id="sidebarSearch" placeholder="Search components..." aria-label="Search components">
                    <img src="assets/search.svg" alt="Search" class="search-icon">
                </div>
                <div class="no-results" id="noResults">No matching components found</div>
            </div>
            <div class="sidebar-menu" id="sidebar-menu">
                <!-- Menu items will be generated by JavaScript -->
            </div>
        </div>
        <button class="fab" id="fabButton" onclick="createComponentManager()"></button>
        <button class="sortFab" id="sortFab" onclick="toggleSidebarSorting()">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                <path d="M21.3,7.6h-6.9c-.9,0-1.5-.7-1.5-1.5h0c0-.9.7-1.5,1.5-1.5h6.9c.9,0,1.5.7,1.5,1.5h0c0,.9-.7,1.5-1.5,1.5ZM22.8,11.7h0c0-.9-.7-1.5-1.5-1.5h-6.2c-.9,0-1.5.7-1.5,1.5h0c0,.9.7,1.5,1.5,1.5h6.2c.9,0,1.5-.7,1.5-1.5ZM22.8,17.2h0c0-.9-.7-1.5-1.5-1.5h-2.8c-.9,0-1.5.7-1.5,1.5h0c0,.9.7,1.5,1.5,1.5h2.8c.9,0,1.5-.7,1.5-1.5ZM2.9,18.8c-.4,0-.7-.1-.9-.3s-.4-.5-.4-.8,0-.6.2-1.1l3.5-10.1c.2-.7.5-1.1.8-1.4s.8-.4,1.4-.4,1,.1,1.4.4.6.8.8,1.4l3.5,10.1c.1.4.2.8.2,1.1s-.1.7-.4.9-.6.3-1,.3-.7-.1-.9-.3-.4-.6-.5-1l-.8-2.4h-4.9l-.8,2.4c-.1.5-.3.8-.5,1s-.5.3-.9.3ZM5.8,13h3.7l-1.8-5.7h-.1l-1.8,5.7Z" />
            </svg>
            <span class="sortFab-tooltip">Default Category Sorting</span>
        </button>
        <button class="sortFab" id="closeFab" onclick="closeSidebarOnMobile()">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                <path d="M14.9,12l4.9-4.9c.7-.7.7-1.8,0-2.5h0c-.7-.7-1.8-.7-2.5,0l-4.9,4.9-4.9-4.9c-.7-.7-1.8-.7-2.5,0h0c-.7.7-.7,1.9,0,2.5l4.9,4.9-4.9,4.9c-.7.7-.7,1.8,0,2.5h0c.7.7,1.8.7,2.5,0l4.9-4.9,4.9,4.9c.7.7,1.8.7,2.5,0h0c.7-.7.7-1.9,0-2.5l-4.9-4.9Z" />
            </svg>
        </button>
        <button class="sidebar-toggle" id="sidebar-toggle">â˜°</button>
        <!-- Theme Toggle Switch -->
        <div class="theme-switch-container">
            <label class="theme-switch">
                <input type="checkbox" id="theme-toggle">
                <span class="theme-slider"></span>
            </label>
            <span class="theme-icon">ðŸŒ™</span>
        </div>

        <div class="content" id="content">
            <!-- Loading indicator -->
            <div id="loading" class="loading">
                <div class="spinner"></div>
                <p>Loading component...</p>
            </div>
        <div class="components-grid">
            <!-- Component Card -->
            <div class="component-item">
                <div class="component-icon">
                </div>
                <div class="component-info">
                    <h3 class="component-title">Accordion</h3>
                    <p class="component-card-description">Info Text</p>
                </div>
            </div>
            <!-- -->
            <!-- Component Card -->
            <div class="component-item">
                <div class="component-icon">
                </div>
                <div class="component-info">
                    <h3 class="component-title">Badges & Tags</h3>
                    <p class="component-card-description">Info Text</p>
                </div>
            </div>
            <!-- -->
            <!-- Component Card -->
            <div class="component-item">
                <div class="component-icon">
                </div>
                <div class="component-info">
                    <h3 class="component-title">Button</h3>
                    <p class="component-card-description">Info Text</p>
                </div>
            </div>
            <!-- -->
        </div>
            <!-- Content will be loaded here -->
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    <script src="js/app.js"></script>
    <script>
        let toggle = true;
        // Menu structure data
        const menuData = [
            {
                "category": "First Steps",
                "items": ["UI component lib"]
            },
            {
                "category": "Button",
                "items": ["Button", "Button Group", "Button Close", "Button with Icon Only", "Social Button", "Store Badges"]
            },
            {
                "category": "Input Fields",
                "items": ["Input"]
            },
            {
                "category": "Checkboxes",
                "items": ["Checkbox", "Checkbox Label"]
            },
            {
                "category": "Radio Buttons",
                "items": ["Radio Button", "Radio Button Group"]
            },
            {
                "category": "Toggles",
                "items": ["Toggle Switch", "Toggle Label"]
            },
            {
                "category": "Drop-Downs",
                "items": ["Drop-Down Box", "Drop-Down Menu"]
            },
            {
                "category": "Tabs",
                "items": ["Horizontal Tabs", "Vertical Tabs", "Tab Button"]
            },
            {
                "category": "Modals",
                "items": ["Modal Header", "Modal Actions"]
            },
            {
                "category": "Pagination",
                "items": ["Pagination", "Pagination Dots"]
            },
            {
                "category": "Progress Loaders",
                "items": ["Linear Loader", "Linear Loader (Looping)", "Radial Loader", "Radial Loader (Looping)", "Radial Loader (Looping) 2"]
            },
            {
                "category": "Badges & Tags",
                "items": ["Badge"]
            },
            {
                "category": "Icons",
                "items": ["Icons"]
            },
            {
                "category": "Content",
                "items": ["Content Frames", "Content Slots", "Content Header", "Content Slot"]
            },
            {
                "category": "Lists",
                "items": ["Check List Item", "Class List Item"]
            },
            {
                "category": "Accordion",
                "items": ["Accordion", "Accordion Item"]
            },
            {
                "category": "Headers",
                "items": ["Card Header", "Page Header", "Section Header"]
            },
            {
                "category": "Dividers",
                "items": ["Divider"]
            },
            {
                "category": "Info Cards",
                "items": ["Info Card"]
            },
            {
                "category": "Empty States",
                "items": ["Empty State", "Empty State Graphic"]
            },
            {
                "category": "Inbox",
                "items": ["Content / Inbox / Classic", "Content / Inbox / Compact", "Mail Navigation List Item"]
            },
            {
                "category": "Signup & Login",
                "items": ["Login Sections", "Signup Sections"]
            },
            {
                "category": "Logos",
                "items": ["GG Logo", "GG Logo Icon", "GG Logo Mark"]
            },
            {
                "category": "Miscellaneous",
                "items": ["Avatar", "Avatar Labeled", "Avatar Stack"]
            }

        ];
        let isAlphabeticalSort = false;
    function sortMenuDataAlphabetically(data) {
        // Find First Steps category
        const firstStepsIndex = data.findIndex(item => item.category === "First Steps");
        let firstStepsCategory = null;

        // Extract First Steps if it exists
        if (firstStepsIndex !== -1) {
            firstStepsCategory = data[firstStepsIndex];
        }

        // Create a new array without First Steps
        const dataWithoutFirstSteps = data.filter(item => item.category !== "First Steps");

        // Sort the remaining categories alphabetically
        const sortedData = [...dataWithoutFirstSteps].sort((a, b) => a.category.localeCompare(b.category));

        // Put First Steps back at the beginning if it existed
        if (firstStepsCategory) {
            sortedData.unshift(firstStepsCategory);
        }

        return sortedData;
    }
    // Modify the regenerateSidebarMenu function to ensure First Steps always appears first
    function regenerateSidebarMenu(sortedData) {
        // Find the currently active item's data
        const currentActiveItem = document.querySelector('.category-item.active');
        const currentActiveItemName = currentActiveItem ? currentActiveItem.getAttribute('data-item') : null;
        const currentActiveItemPage = currentActiveItem ? currentActiveItem.getAttribute('data-page') : null;
        const sidebarMenu = document.getElementById('sidebar-menu');
        const sortToggle = document.getElementById('sort-toggle-icon');
        sidebarMenu.innerHTML = ''; // Clear everything

        // Re-add the sort toggle as the first child
        sidebarMenu.appendChild(sortToggle.parentElement);

        // Ensure First Steps is first by reordering the data array if needed
        let reorderedData = [...sortedData];
        const firstStepsIndex = reorderedData.findIndex(item => item.category === "First Steps");

        // If First Steps exists and isn't already first, move it to the top
        if (firstStepsIndex > 0) {
            const firstStepsCategory = reorderedData.splice(firstStepsIndex, 1)[0];
            reorderedData.unshift(firstStepsCategory);
        }

        // Regenerate menu with the provided data (now with First Steps first)
        reorderedData.forEach((menuItem) => {
            const categoryElement = document.createElement('div');
            categoryElement.className = 'category';

            // Apply special class for First Steps category
            if (menuItem.category === "First Steps") {
                categoryElement.classList.add('category-pinned');
            }

            categoryElement.innerHTML = `
            <div class="category-header">
                ${menuItem.category}
                <span class="toggle-icon">â—‹</span>
            </div>
            <div class="category-items">
                ${menuItem.items.map(item => {
                const itemId = item.toLowerCase().replace(/\s+/g, '-').replace(/\//g, '-');
                const isActive = item === currentActiveItemName ? "active" : "";

                return `
                        <a href="#" class="category-item ${isActive}" data-item="${item}" data-page="${itemId}">
                            ${item}
                            <span class="category-item-indicator"></span>
                        </a>
                    `;
            }).join('')}
            </div>
        `;
            sidebarMenu.appendChild(categoryElement);

            // Update the category's active state based on the active item
            if (menuItem.items.includes(currentActiveItemName)) {
                categoryElement.classList.add('active');
                categoryElement.querySelector('.toggle-icon').textContent = 'â¬¤';
            }
        });

        // Re-add event listeners to category headers
        document.querySelectorAll('.category-header').forEach(header => {
            header.addEventListener('click', () => {
                const parent = header.parentElement;
                const toggleIcon = header.querySelector('.toggle-icon');
                const isActive = parent.classList.contains('active');

                // Close all categories first
                document.querySelectorAll('.category').forEach(cat => {
                    cat.classList.remove('active');
                    cat.querySelector('.toggle-icon').textContent = 'â—‹';
                });

                document.querySelectorAll('.category-item').forEach(i => {
                    i.classList.remove('active');
                });

                if (!isActive) {
                    parent.classList.add('active');
                    toggleIcon.textContent = 'â¬¤';

                    const firstItem = parent.querySelector('.category-item');
                    if (firstItem) {
                        firstItem.classList.add('active');
                        const pageName = firstItem.getAttribute('data-page');
                        loadContent(pageName);
                        scrollToTop();
                        closeSidebarOnMobile();
                    }
                }
            });
        });

        // Use the new function to add event listeners to category items
        addCategoryItemListeners();

        // If we had an active item before, load its content
        if (currentActiveItemPage) {
            loadContent(currentActiveItemPage);
        }
    }


        // Function to sort menu data alphabetically
        function sortMenuDataAlphabetically(data) {
            return [...data].sort((a, b) => a.category.localeCompare(b.category));
        }

        function toggleSidebarSorting() {
            isAlphabeticalSort = !isAlphabeticalSort;
            const sortFab = document.getElementById('sortFab');
            // Update menu based on sorting mode
            if (isAlphabeticalSort) {
                sortFab.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                <path d="M11,14.9l-3.5,3.5c-.3.3-.7.4-1,.4-.4,0-.7,0-1-.4l-3.5-3.5c-.5-.5-.5-1.3,0-1.9.5-.5,1.3-.5,1.9,0l1.4,1.4V5.8c0-.7.6-1.3,1.3-1.3s1.3.6,1.3,1.3v8.5l1.4-1.4c.5-.5,1.3-.5,1.9,0s.5,1.3,0,1.9ZM22.8,6.1h0c0-.9-.7-1.5-1.5-1.5h-6.9c-.9,0-1.5.7-1.5,1.5h0c0,.9.7,1.5,1.5,1.5h6.9c.9,0,1.5-.7,1.5-1.5ZM21.3,13.2h-6.2c-.9,0-1.5-.7-1.5-1.5h0c0-.9.7-1.5,1.5-1.5h6.2c.9,0,1.5.7,1.5,1.5h0c0,.9-.7,1.5-1.5,1.5ZM21.3,18.8h-2.8c-.9,0-1.5-.7-1.5-1.5h0c0-.9.7-1.5,1.5-1.5h2.8c.9,0,1.5.7,1.5,1.5h0c0,.9-.7,1.5-1.5,1.5Z"/>
            </svg>
            <span class="sortFab-tooltip">Default Category Sorting</span>`;
                // Sort menu alphabetically
                const sortedMenuData = sortMenuDataAlphabetically(menuData);
                regenerateSidebarMenu(sortedMenuData);
            } else {
                sortFab.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                <path d="M21.3,7.6h-6.9c-.9,0-1.5-.7-1.5-1.5h0c0-.9.7-1.5,1.5-1.5h6.9c.9,0,1.5.7,1.5,1.5h0c0,.9-.7,1.5-1.5,1.5ZM22.8,11.7h0c0-.9-.7-1.5-1.5-1.5h-6.2c-.9,0-1.5.7-1.5,1.5h0c0,.9.7,1.5,1.5,1.5h6.2c.9,0,1.5-.7,1.5-1.5ZM22.8,17.2h0c0-.9-.7-1.5-1.5-1.5h-2.8c-.9,0-1.5.7-1.5,1.5h0c0,.9.7,1.5,1.5,1.5h2.8c.9,0,1.5-.7,1.5-1.5ZM2.9,18.8c-.4,0-.7-.1-.9-.3s-.4-.5-.4-.8,0-.6.2-1.1l3.5-10.1c.2-.7.5-1.1.8-1.4s.8-.4,1.4-.4,1,.1,1.4.4.6.8.8,1.4l3.5,10.1c.1.4.2.8.2,1.1s-.1.7-.4.9-.6.3-1,.3-.7-.1-.9-.3-.4-.6-.5-1l-.8-2.4h-4.9l-.8,2.4c-.1.5-.3.8-.5,1s-.5.3-.9.3ZM5.8,13h3.7l-1.8-5.7h-.1l-1.8,5.7Z"/>
            </svg>
            <span class="sortFab-tooltip">Alphabetical Sorting</span>`;
                // Revert to original order
                regenerateSidebarMenu(menuData);
            }
        }

        // Generate menu
        const sidebarMenu = document.getElementById('sidebar-menu');
        const contentContainer = document.getElementById('content');
        const loadingIndicator = document.getElementById('loading');

        menuData.forEach((menuItem, index) => {
            const categoryElement = document.createElement('div');
            categoryElement.className = 'category';

            // Pre-expand the Buttons category
            if (menuItem.category === "First Steps") {
                categoryElement.classList.add('active');
            }

            categoryElement.innerHTML = `
                <div class="category-header">
                    ${menuItem.category}
                    <span class="toggle-icon">${menuItem.category === "UI component lib" ? 'â¬¤' : 'â—‹'}</span>
                </div>
                <div class="category-items">
                    ${menuItem.items.map(item => {
                // Set Button as active by default
                const isActive = item === "UI component lib" ? "active" : "";
                // Create URL-friendly id from item name
                const itemId = item.toLowerCase().replace(/\s+/g, '-').replace(/\//g, '-');

                return `
                        <a href="#" class="category-item ${isActive}" data-item="${item}" data-page="${itemId}">
                            ${item}
                            <span class="category-item-indicator"></span>
                        </a>
                    `;
            }).join('')}
                </div>
            `;
            sidebarMenu.appendChild(categoryElement);
        });

        // Add this function to your JavaScript
        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'  // For smooth scrolling
            });
        }
        const componentRepository = {
            // Example structure - you'll need to populate this with your actual data
        };

        function populateComponentRepository() {
            // This function will create entries in componentRepository based on menu data
            menuData.forEach(category => {
                category.items.forEach(item => {
                    // Create URL-friendly id from item name
                    const itemId = item.toLowerCase().replace(/\s+/g, '-').replace(/\//g, '-');

                    // Only add if not already in repository
                    if (!componentRepository[itemId]) {
                        componentRepository[itemId] = {
                            name: item,
                            description: "", // Empty by default
                            figmaLink: "", // Empty by default
                            figmaButtonText: item,
                            imagePath1: "", // Empty by default - for first image
                            imagePath2: ""  // Empty by default - for second image
                        };
                    }
                });
            });
        }

    // Function to initialize Lottie animations
    function initializeLottieAnimations() {
        // Find all elements with data-lottie-path attribute
        const lottieContainers = document.querySelectorAll('[data-lottie-path]');

        lottieContainers.forEach(container => {
            const path = container.getAttribute('data-lottie-path');
            const loop = container.getAttribute('data-lottie-loop') !== 'false';
            const autoplay = container.getAttribute('data-lottie-autoplay') !== 'false';

            // Load the Lottie animation
            fetch(path)
                .then(response => response.json())
                .then(animationData => {
                    const animation = lottie.loadAnimation({
                        container: container,
                        renderer: 'svg',
                        loop: loop,
                        autoplay: autoplay,
                        animationData: animationData
                    });

                    // Add click handler to toggle play/pause if autoplay is false
                    if (!autoplay) {
                        container.style.cursor = 'pointer';
                        container.addEventListener('click', () => {
                            if (animation.isPaused) {
                                animation.play();
                            } else {
                                animation.pause();
                            }
                        });
                    }
                })
                .catch(error => {
                    console.error('Error loading Lottie animation:', error);
                    container.innerHTML = 'Failed to load animation';
                });
        });
    }

    // Add this function to handle tab switching
    function initializeTabSwitching() {
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Remove active class from all buttons and contents
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));

                // Add active class to clicked button and corresponding content
                button.classList.add('active');
                const tabId = `${button.dataset.tab}-tab`;
                const tabContent = document.getElementById(tabId);

                if (tabContent) {
                    tabContent.classList.add('active');
                }
            });
        });
    }

    // Modified loadContent function
    async function loadContent(pageName) {
        try {
            // Show loading indicator
            loadingIndicator.classList.add('active');

            // Prepare content container for fade out
            contentContainer.classList.add('fade-out');

            // Wait a short moment to allow fade out to be visible
            await new Promise(resolve => setTimeout(resolve, 200));

            // Check if this is the default page (ui-component-lib)
            if (pageName === 'ui-component-lib') {
                // Hide loading indicator
                loadingIndicator.classList.remove('active');

                // Create the content header
                const contentHeader = `
                <div class="content-header">
                    <h1 class="content-title">Component Library</h1>
                    <p class="content-subtitle">Select a component category to explore</p>
                </div>
            `;

                // Generate cards for each category in the menu
                let categoriesHTML = '<div class="components-grid">';

                menuData.forEach(category => {
                    // Skip the "First Steps" category in the grid
                    if (category.category !== "First Steps") {
                        // Create a URL-friendly id from category name
                        const categoryId = category.category.toLowerCase().replace(/\s+/g, '-').replace(/\//g, '-');

                        // Create image path for the category icon
                        const imagePath = `assets/cards/${categoryId}.webp`;

                        categoriesHTML += `
                        <div class="component-item" data-category="${categoryId}">
                            <div class="component-icon">
                                <img src="${imagePath}" alt="${category.category} icon">
                            </div>
                            <div class="component-info">
                                <h3 class="component-title">${category.category}</h3>
                                <p class="component-card-description">${category.items.length} components</p>
                            </div>
                        </div>
                    `;
                    }
                });

                categoriesHTML += '</div>';

                // Load the content from ui-component-lib.html
                let additionalContent = '';
                try {
                    const response = await fetch('pages/ui-component-lib.html');
                    if (response.ok) {
                        additionalContent = await response.text();
                    }
                } catch (error) {
                    console.error('Error loading ui-component-lib.html:', error);
                    additionalContent = '<p>Additional content could not be loaded.</p>';
                }

                // Update the content container with both the category grid and additional content
                contentContainer.innerHTML = contentHeader + categoriesHTML + '<div class="additional-content">' + additionalContent + '</div>';
                contentContainer.offsetWidth;
                contentContainer.classList.remove('fade-out');
                contentContainer.classList.add('fade-in');

                // Add click event to category cards
                setTimeout(() => {
                    document.querySelectorAll('.component-item').forEach(card => {
                        card.addEventListener('click', () => {
                            const categoryName = card.querySelector('.component-title').textContent;

                            // Find the category in the sidebar - use exact match instead of includes
                            document.querySelectorAll('.category-header').forEach(header => {
                                // Get just the text without the toggle icon
                                const headerText = header.childNodes[0].textContent.trim();
                                if (headerText === categoryName) {
                                    // Trigger a click on this category header
                                    header.click();
                                }
                            });
                        });
                    });

                    // Remove fade in class to reset for next transition
                    contentContainer.classList.remove('fade-in');

                    // Initialize video viewport observers for any videos in the additional content
                    initializeVideos();

                    // Initialize image sliders if any exist in the additional content
                    initializeImageSliders();

                    // Initialize Lottie animations after content is loaded
                    initializeLottieAnimations();

                    // Initialize tab switching after content is loaded
                    requestAnimationFrame(() => {
                        initializeTabSwitching();
                        initializeVideos();
                        initializeLottieAnimations();
                    });
                }, 300);

                return;
            }

            // For non-default pages, continue with the original logic
            const response = await fetch(`pages/${pageName}.html`);

            if (!response.ok) {
                throw new Error(`Failed to load ${pageName}`);
            }

            const html = await response.text();

            // Hide loading indicator
            loadingIndicator.classList.remove('active');

            // Create the content header
            const contentHeader = `
            <div class="content-header">
                <h1 class="content-title">${pageName.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</h1>
            </div>
        `;
            contentContainer.innerHTML = contentHeader + html;
            contentContainer.offsetWidth;
            contentContainer.classList.remove('fade-out');
            contentContainer.classList.add('fade-in');

            // Remove loading state code for Figma containers
            await new Promise(resolve => setTimeout(resolve, 300));

            // Remove fade in class to reset for next transition
            contentContainer.classList.remove('fade-in');

            // Wait for the DOM to update before injecting component info
            requestAnimationFrame(() => {
                // After content is loaded, inject component information
                injectComponentInfo(pageName);

                // Initialize video viewport observers
                initializeVideos();

                // Initialize Lottie animations
                initializeLottieAnimations();

                // Initialize tab switching after content is loaded
                requestAnimationFrame(() => {
                    initializeTabSwitching();
                    initializeVideos();
                    initializeLottieAnimations();
                });
            });
        } catch (error) {
            console.error('Error loading content:', error);
            loadingIndicator.classList.remove('active');
            contentContainer.classList.remove('fade-out');
            contentContainer.innerHTML = `
            <div class="content-header">
                <h1 class="content-title">${pageName.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</h1>
                <p class="content-subtitle">Content not found or still in development</p>
            </div>
            <div style="text-align: center; padding: 50px;">
                <p>We're still working on this component. Check back soon!</p>
            </div>
        `;
        }
    }
        // Function to inject component information into the loaded page
        function injectComponentInfo(pageName) {
            // Add a small delay to ensure DOM is ready
            setTimeout(() => {
                console.log(`Injecting data for component: ${pageName}`);

                // Look up the component data from our repository
                const componentData = componentRepository[pageName];

                if (!componentData) {
                    console.log(`No stored data found for component: ${pageName}`);
                    return;
                }

                // Find the component description element - try different selectors
                const descriptionElement = document.querySelector('.component-description p') ||
                    document.querySelector('.component-description') ||
                    document.querySelector('[data-description-container]');

                if (descriptionElement && componentData.description) {
                    console.log('Found description element, updating content');
                    descriptionElement.textContent = componentData.description;
                } else {
                    console.log('Description element not found in the DOM');
                }

                // Find the Figma link button - try different selectors
                const figmaLink = document.querySelector('.two-tone-button') ||
                    document.querySelector('[data-figma-link]') ||
                    document.querySelector('a[href*="figma.com"]');

                if (figmaLink && componentData.figmaLink) {
                    console.log('Found Figma link element, updating href');
                    figmaLink.setAttribute('href', componentData.figmaLink);

                    // Update button text if needed
                    const buttonLeftElement = figmaLink.querySelector('.button-left');
                    if (buttonLeftElement && componentData.figmaButtonText) {
                        // Save the diamond icon HTML
                        const diamondIcon = buttonLeftElement.querySelector('.diamond-icon');
                        const diamondHtml = diamondIcon ? diamondIcon.outerHTML : '';

                        // Replace the content, preserving the diamond icon
                        buttonLeftElement.innerHTML = componentData.figmaButtonText + diamondHtml;
                    }
                } else {
                    console.log('Figma link element not found in the DOM');
                }

                // Find and update images if paths are provided
                if (componentData.imagePath1 || componentData.imagePath2) {
                    console.log('Found image paths, searching for image elements');

                    // Find all grid-2-col grids in the loaded content
                    const gridContainers = document.querySelectorAll('.grid-2-col');

                    gridContainers.forEach(gridContainer => {
                        // Find images within this specific grid
                        const gridImages = gridContainer.querySelectorAll('.grid-item img[data-prop-img]');

                        // Update first image if found
                        if (gridImages.length > 0 && componentData.imagePath1) {
                            console.log('Updating first image src');
                            gridImages[0].setAttribute('src', componentData.imagePath1);
                            gridImages[0].setAttribute('alt', `${componentData.name} - diagram 1`);

                            // Hide the grid item if image is empty.png
                            const firstGridItem = gridImages[0].closest('.grid-item');
                            if (componentData.imagePath1.endsWith('empty.png')) {
                                if (firstGridItem) firstGridItem.classList.add('hidden');
                            } else {
                                if (firstGridItem) firstGridItem.classList.remove('hidden');
                            }
                        }

                        // Update second image if found
                        if (gridImages.length > 1 && componentData.imagePath2) {
                            console.log('Updating second image src');
                            gridImages[1].setAttribute('src', componentData.imagePath2);
                            gridImages[1].setAttribute('alt', `${componentData.name} - diagram 2`);

                            // Hide the grid item if image is empty.png
                            const secondGridItem = gridImages[1].closest('.grid-item');
                            if (componentData.imagePath2.endsWith('empty.png')) {
                                if (secondGridItem) secondGridItem.classList.add('hidden');
                            } else {
                                if (secondGridItem) secondGridItem.classList.remove('hidden');
                            }
                        }

                        // Adjust grid layout based on visible items
                        const visibleGridItems = gridContainer.querySelectorAll('.grid-item:not(.hidden)');

                        if (visibleGridItems.length === 1) {
                            gridContainer.classList.add('single-column');
                        } else {
                            gridContainer.classList.remove('single-column');
                        }
                    });
                }
            }, 100); // Small delay to ensure DOM is updated
            // Call slider initialization
            requestAnimationFrame(initializeImageSliders);
        }

        // Function to save component data to downloadable JSON file
        function saveComponentRepository() {
            // Save to localStorage as a backup/cache
            localStorage.setItem('componentRepository', JSON.stringify(componentRepository));

            // Create formatted JSON string
            const jsonData = JSON.stringify(componentRepository, null, 2);

            // Create a blob containing the JSON data
            const blob = new Blob([jsonData], { type: 'application/json' });

            // Create a URL for the blob
            const url = URL.createObjectURL(blob);

            // Create a link element for downloading
            const link = document.createElement('a');
            link.href = url;
            link.download = 'components.json';

            // Append link to body, click it, and remove it
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            // Clean up the URL object
            URL.revokeObjectURL(url);

            console.log('Component repository saved to downloadable JSON file');

            // Display instructions for the user
            alert('Component data has been saved as components.json. To make this data available for future visits, please replace the components.json file in your project\'s data directory with this downloaded file.');
        }
        // Function to load component data from JSON file
        async function loadComponentRepository() {
            try {
                // Fetch the JSON file
                const response = await fetch('data/components.json');

                if (!response.ok) {
                    throw new Error(`Failed to load component data: ${response.status}`);
                }

                const loadedData = await response.json();

                // Merge the loaded data with our default data
                Object.assign(componentRepository, loadedData);
                console.log('Component repository loaded from JSON file');

                // Also save to localStorage as a backup/cache
                localStorage.setItem('componentRepository', JSON.stringify(componentRepository));
            } catch (error) {
                console.error('Error loading component repository from file:', error);

                // Fall back to localStorage if available
                const storedData = localStorage.getItem('componentRepository');
                if (storedData) {
                    try {
                        const localData = JSON.parse(storedData);
                        Object.assign(componentRepository, localData);
                        console.log('Component repository loaded from localStorage fallback');
                    } catch (e) {
                        console.error('Error parsing localStorage data:', e);
                    }
                }
            } finally {
                // Ensure we have entries for all components by populating missing ones
                populateComponentRepository();
            }
        }
        // Add this function to ensure consistent sidebar closing behavior
        function closeSidebarOnMobile() {
            if (window.innerWidth <= 768) {
                const sidebar = document.getElementById('sidebar');
                sidebar.classList.remove('active');
                document.body.classList.remove('sidebar-open');
            }
        }
        // Add event listeners to category headers - updated to close other categories and activate first item
        document.querySelectorAll('.category-item').forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();

                // Check if the clicked item is already active
                if (item.classList.contains('active')) {
                    // If already active, do nothing and return
                    return;
                }

                // Remove active class from all items
                document.querySelectorAll('.category-item').forEach(i => {
                    i.classList.remove('active');
                });

                // Add active class to clicked item
                item.classList.add('active');

                // Get page name
                const pageName = item.getAttribute('data-page');

                // Load the content
                loadContent(pageName);

                // Scroll to top
                scrollToTop();

                // Close sidebar on mobile
                closeSidebarOnMobile();
            });
        });

        // Add event listeners for sidebar toggle on mobile
        const sidebarToggle = document.getElementById('sidebar-toggle');
        const sidebar = document.getElementById('sidebar');
        const searchInput = document.getElementById('sidebarSearch');

        sidebarToggle.addEventListener('click', () => {
            sidebar.classList.toggle('active');
            document.body.classList.toggle('sidebar-open');
        });

        // Close sidebar and clear search when clicking outside
        document.addEventListener('click', (e) => {
            // Check if click is outside sidebar
            if (!sidebar.contains(e.target) &&
                !sidebarToggle.contains(e.target)) {

                // Store the currently active item and its category before clearing search
                const activeItem = document.querySelector('.category-item.active');
                const activeCategory = activeItem ? activeItem.closest('.category') : null;

                // Clear search if it has value
                if (searchInput.value) {
                    searchInput.value = '';
                    searchInput.dispatchEvent(new Event('input'));
                    
                    // After search is cleared, restore the active state
                    if (activeItem && activeCategory) {
                        // Close all categories first
                        document.querySelectorAll('.category').forEach(cat => {
                            cat.classList.remove('active');
                            cat.querySelector('.toggle-icon').textContent = 'â—‹';
                        });

                        // Restore active category
                        activeCategory.classList.add('active');
                        activeCategory.querySelector('.toggle-icon').textContent = 'â¬¤';

                        // Make sure the active item is visible and active
                        activeItem.classList.remove('hidden');
                        activeItem.classList.add('active');
                    }
                }

                // Close sidebar on mobile if it's open
                if (window.innerWidth <= 768 && sidebar.classList.contains('active')) {
                    sidebar.classList.remove('active');
                    document.body.classList.remove('sidebar-open');
                }
            }
        });

        // Update the category item click event
        function addCategoryItemListeners() {
            document.querySelectorAll('.category-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.preventDefault();

                    // Clear search if it was used
                    const searchInput = document.getElementById('sidebarSearch');
                    const searchIcon = document.querySelector('.search-icon');
                    if (searchInput.value) {
                        searchInput.value = '';
                        searchIcon.src = 'assets/search.svg';
                        
                        // Reset all categories and items visibility
                        document.querySelectorAll('.category').forEach(cat => {
                            cat.classList.remove('hidden', 'search-active');
                            cat.querySelectorAll('.category-item').forEach(i => {
                                i.classList.remove('hidden');
                                // Restore original text without highlights
                                const text = i.textContent.trim();
                                const indicator = i.querySelector('.category-item-indicator');
                                i.innerHTML = text + (indicator ? indicator.outerHTML : '');
                            });
                        });
                        
                        // Hide no results message if visible
                        document.getElementById('noResults').classList.remove('visible');
                    }

                    // Remove active class from all items
                    document.querySelectorAll('.category-item').forEach(i => {
                        i.classList.remove('active');
                    });

                    // Add active class to clicked item
                    item.classList.add('active');

                    // Close all categories first
                    document.querySelectorAll('.category').forEach(cat => {
                        cat.classList.remove('active');
                        cat.querySelector('.toggle-icon').textContent = 'â—‹';
                    });

                    // Open the parent category of the clicked item
                    const parentCategory = item.closest('.category');
                    if (parentCategory) {
                        parentCategory.classList.add('active');
                        parentCategory.querySelector('.toggle-icon').textContent = 'â¬¤';
                    }

                    // Get page name and load content
                    const pageName = item.getAttribute('data-page');
                    loadContent(pageName);

                    // Scroll to top
                    scrollToTop();

                    // Close sidebar on mobile
                    closeSidebarOnMobile();
                });
            });
        }

        // Function to initialize video viewport observers
        function initializeVideos() {
            const videos = document.querySelectorAll('video');

            if (videos.length === 0) return;

            // For each video, add status indicator and set up IntersectionObserver
            videos.forEach((video, index) => {
                // Add unique ID to each video
                video.id = `video-${index}`;

                // Add status indicator to video container
                const videoContainer = video.closest('.video-container') || video.parentElement;

                // Only add indicator if it doesn't already exist
                if (!videoContainer.querySelector('.video-status-indicator')) {
                    const statusIndicator = document.createElement('div');
                    statusIndicator.className = 'video-status-indicator';
                    statusIndicator.textContent = 'Paused';
                    statusIndicator.id = `indicator-${index}`;
                    videoContainer.style.position = 'relative';
                    videoContainer.appendChild(statusIndicator);
                }

                // Create Intersection Observer to watch each video
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        // Get status indicator for this video
                        const indicator = document.getElementById(`indicator-${index}`);

                        if (entry.isIntersecting) {
                            // Video is in viewport
                            // Pause all other videos first
                            videos.forEach(otherVideo => {
                                if (otherVideo.id !== video.id) {
                                    otherVideo.pause();
                                    // Update other indicators
                                    const otherIndex = otherVideo.id.split('-')[1];
                                    const otherIndicator = document.getElementById(`indicator-${otherIndex}`);
                                    if (otherIndicator) otherIndicator.textContent = 'Paused';
                                }
                            });

                            // Play this video
                            if (video.paused) {
                                const playPromise = video.play();

                                // Handle play promise (to avoid DOMException)
                                if (playPromise !== undefined) {
                                    playPromise.then(() => {
                                        // Video playback started successfully
                                        if (indicator) indicator.textContent = 'Playing';
                                    }).catch(error => {
                                        // Auto-play was prevented (e.g., browser policy)
                                        console.log("Auto-play prevented:", error);
                                        if (indicator) indicator.textContent = 'Click to play';
                                    });
                                }
                            }
                        } else {
                            // Video is out of viewport, pause it
                            video.pause();
                            if (indicator) indicator.textContent = 'Paused';
                        }
                    });
                }, {
                    threshold: 0.5 // At least 50% of the video must be visible
                });

                // Start observing the video
                observer.observe(video);

                // Add click event to toggle play/pause manually
                video.addEventListener('click', () => {
                    const indicator = document.getElementById(`indicator-${index}`);

                    if (video.paused) {
                        // Pause all other videos first
                        videos.forEach(otherVideo => {
                            if (otherVideo.id !== video.id) {
                                otherVideo.pause();
                                // Update other indicators
                                const otherIndex = otherVideo.id.split('-')[1];
                                const otherIndicator = document.getElementById(`indicator-${otherIndex}`);
                                if (otherIndicator) otherIndicator.textContent = 'Paused';
                            }
                        });

                        // Play this video
                        video.play();
                        if (indicator) indicator.textContent = 'Playing';
                    } else {
                        video.pause();
                        if (indicator) indicator.textContent = 'Paused';
                    }
                });

                // Update indicator when video plays/pauses
                video.addEventListener('play', () => {
                    const indicator = document.getElementById(`indicator-${index}`);
                    if (indicator) indicator.textContent = 'Playing';
                });

                video.addEventListener('pause', () => {
                    const indicator = document.getElementById(`indicator-${index}`);
                    if (indicator) indicator.textContent = 'Paused';
                });
            });
        }
        // Update the search functionality
        function initializeSearch() {
            const searchInput = document.getElementById('sidebarSearch');
            const noResults = document.getElementById('noResults');
            const searchIcon = document.querySelector('.search-icon');
            const searchIconPath = 'assets/search.svg';
            const closeIconPath = 'assets/close.svg';

            searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase().trim();
                const categories = document.querySelectorAll('.category');
                let hasResults = false;

                // Update icon based on search input
                searchIcon.src = searchTerm ? closeIconPath : searchIconPath;

                categories.forEach(category => {
                    const categoryHeader = category.querySelector('.category-header');
                    const categoryName = categoryHeader.textContent.trim().toLowerCase();
                    const items = category.querySelectorAll('.category-item');
                    let categoryHasVisibleItems = false;

                    // Search through items in this category
                    items.forEach(item => {
                        const itemName = item.textContent.trim().toLowerCase();
                        const isMatch = itemName.includes(searchTerm) || categoryName.includes(searchTerm);

                        if (isMatch) {
                            item.classList.remove('hidden');
                            categoryHasVisibleItems = true;
                            hasResults = true;

                            // Highlight matching text if there's a search term
                            if (searchTerm) {
                                const originalText = item.textContent.trim();
                                const regex = new RegExp(searchTerm, 'gi');
                                const highlightedText = originalText.replace(regex, match =>
                                    `<span class="highlight">${match}</span>`
                                );
                                // Preserve the indicator span and wrap text in a span
                                const indicator = item.querySelector('.category-item-indicator');
                                item.innerHTML = `<span>${highlightedText}</span>` + (indicator ? indicator.outerHTML : '');
                            }
                        } else {
                            item.classList.add('hidden');
                        }
                    });

                    // Show/hide category based on whether it has visible items
                    if (categoryHasVisibleItems || categoryName.includes(searchTerm)) {
                        category.classList.remove('hidden');
                        if (searchTerm) {
                            category.classList.add('active');
                            category.classList.add('search-active');
                        } else {
                            category.classList.remove('search-active');
                        }
                    } else {
                        category.classList.add('hidden');
                        category.classList.remove('search-active');
                        if (searchTerm) {
                            category.classList.remove('active');
                        }
                    }
                });

                // Show/hide no results message
                noResults.classList.toggle('visible', !hasResults);

                // If search is cleared, reset everything
                if (!searchTerm) {
                    categories.forEach(category => {
                        category.classList.remove('hidden');
                        category.classList.remove('active');
                        category.classList.remove('search-active');
                        category.querySelectorAll('.category-item').forEach(item => {
                            item.classList.remove('hidden');
                            // Restore original text without highlights
                            const text = item.textContent.trim();
                            const indicator = item.querySelector('.category-item-indicator');
                            item.innerHTML = text + (indicator ? indicator.outerHTML : '');
                        });
                    });
                    noResults.classList.remove('visible');
                }
            });

            // Clear search when clicking the search/close icon
            searchIcon.addEventListener('click', () => {
                searchInput.value = '';
                searchInput.dispatchEvent(new Event('input'));
                searchIcon.src = searchIconPath;
            });

            // Add keyboard shortcut (Escape) to clear search
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    searchInput.value = '';
                    searchInput.dispatchEvent(new Event('input'));
                    searchIcon.src = searchIconPath;
                    searchInput.blur();
                }
            });
        }

        // Add this to your initializeApp function
        async function initializeApp() {
            // Add search functionality initialization
            initializeSearch();

            // Add sorting toggle to the sidebar
            const sidebarMenu = document.getElementById('sidebar-menu');
            const sortFabBtn = document.getElementById('sortFab');
            const sortToggleContainer = document.createElement('div');
            sortToggleContainer.className = 'sidebar-sort-toggle';
            sortToggleContainer.innerHTML = `
        <span id="sort-toggle-icon" class="sort-toggle-icon">ðŸ“‹</span>
    `;

            // Ensure the sort toggle is the first child of the sidebar menu
            sidebarMenu.insertBefore(sortToggleContainer, sidebarMenu.firstChild);

            // Get the sort toggle icon
            const sortToggleIcon = document.getElementById('sort-toggle-icon');

            // Add click event to toggle sorting
            sortToggleIcon.addEventListener('click', toggleSidebarSorting);

            // First try to load data from the JSON file
            await loadComponentRepository();

            // Add category item listeners using the new function
            addCategoryItemListeners();

            // Only call loadContent once with the default component
            loadContent('ui-component-lib');

            // Initialize video functionality
            initializeVideos();

            // Trigger sortFab click twice after a short delay
            setTimeout(() => {
                sortFabBtn.click();
                setTimeout(() => {
                    sortFabBtn.click();
                }, 100);
            }, 500);

            // Add Component Manager to the "First Steps" category
            setTimeout(() => {
                document.querySelectorAll('.category-header').forEach(header => {
                    if (header.textContent.trim().includes('First Steps')) {
                        firstStepsCategory = header.parentElement;
                    }
                });

                if (firstStepsCategory) {
                    // Find the items container
                    const itemsContainer = firstStepsCategory.querySelector('.category-items');

                    if (itemsContainer) {
                        // Create a new item for the component manager
                        const managerItem = document.createElement('a');
                        managerItem.href = '#';
                        managerItem.className = 'category-item';
                        managerItem.setAttribute('data-item', 'Component Manager');
                        managerItem.setAttribute('data-page', 'component-manager');
                        managerItem.innerHTML = `
                Component Data Manager
                <span class="category-item-indicator"></span>
            `;

                        // Add click event
                        managerItem.addEventListener('click', (e) => {
                            e.preventDefault();

                            // Remove active class from all items
                            document.querySelectorAll('.category-item').forEach(i => {
                                i.classList.remove('active');
                            });

                            // Add active class to clicked item
                            managerItem.classList.add('active');

                            // Display the component manager
                            createComponentManager();

                            // Scroll to top
                            scrollToTop();

                            // Close sidebar on mobile
                            closeSidebarOnMobile();
                        });

                        // Add to the container
                        itemsContainer.appendChild(managerItem);
                    }
                }
            }, 200);
        };
        // Theme Toggle Functionality
        const themeToggle = document.getElementById('theme-toggle');

        // Check for saved theme preference or use system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            document.documentElement.setAttribute('data-theme', 'dark');
            themeToggle.checked = true;
        }

        // Toggle theme when switch is clicked
        themeToggle.addEventListener('change', function () {
            if (this.checked) {
                document.documentElement.setAttribute('data-theme', 'dark');
                localStorage.setItem('theme', 'dark');
            } else {
                document.documentElement.setAttribute('data-theme', 'light');
                localStorage.setItem('theme', 'light');
            }
        });

        window.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>

</html>